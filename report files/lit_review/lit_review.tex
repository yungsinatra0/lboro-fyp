\chapter{Literature Review}

This chapter will provide a review of the existing literature, which will be used guide the student in their planning and development efforts of the project.

\noindent As such, it will be covering the following areas:
\begin{itemize}
    \item Software development methodologies
    \item Requirement gathering
    \item System design
    \item Tech stack
    \item Machine Learning models
    \item Gap Analysis
\end{itemize}

\section{Software development methodologies}

\subsection{Software Development Life Cycle}

The Software Development Life Cycle (SDLC) is a process used to guide the development of software applications or systems \parencite{sdlc1}. The SDLC consists of multiple phases, each with its own set of activities and deliverables. \textcite{sdlc2} outline the phases of the SDLC as following:
\begin{enumerate}
    \item Requirement gathering and analysis phase - This phase involves gathering and analyzing the requirements of the software to be developed. These requirements are gathered from the project stakeholders and saved in a specific document. Based on the requirements gathered, a development plan is created and a feasibility study is conducted.
    \item Design phase - This phase involves representing the previously gathered requirements in a project design written in a more technical manner, that will later guide the developers to create and implement the software. 
    \item Implementation phase - This phase involves the actual development of the software. Additionally, some smaller unit tests may occur during this phase as parts of the software are developed.
    \item Testing phase - This phase focuses on testing the software to ensure that it meets the requirements and is free of bugs. This phase may involve multiple types of testing, such as unit testing, integration testing,  and system testing. \textcite{testing} describes the different types of tests as following:
    \begin{itemize}
    \item Unit testing - This type of test is done on the lowest level of the software, testing individual units or components of the software.
    \item Integration testing - This type of test is performed on two or more units combined together, usually focusing on the interfaces between these components.
    \item System testing - This type of test focuses on the `end-to-end quality of the entire system', testing it as a whole based on the system requirement specification.
    \end{itemize}
    \item Maintenance phase - This phase involves the deployment and maintenance of the software. Additionally, this phase may include user acceptance testing, where the software is handed over to the end-users to ensure that it meets their needs \parencite{testing}. 
\end{enumerate}


\subsection{SDLC Models}

The literature describes several SDLC models that have been used in the development of software applications. \textcite{sdlc1, sdlc2} outline the most common SDLC models:
\begin{itemize}
    \item Waterfall Model
    \item V Model
    \item Spiral Model
    \item Iterative Model
    \item Agile model
\end{itemize}

Due to the nature of the project being different to traditional software development projects, and the student's familiarity with only Waterfall and Agile models, the next sections will only focus on these two models.

\subsubsection{Waterfall Model}

The Waterfall Model is probably the most well-known SDLC model. Waterfall is a linear model, where the development process is divided into distinct, sequential phases that follow the SDLC. As such, each phase must be completed before the next phase can begin.

The Waterfall Model's strengths lie in its simplicty of use, ease of understanding and providing a structured approach to a project \parencite{waterfall}. An additional stregth of the Waterfall model that the authors note is its extensive documentation and planning, which is done in the early stages of a project, but also maintened throughout the project's lifecycle. These two factors also help minimize the overhead that comes with planning and management of a project, which in the case of Waterfall is done in the early stages of the project.

However, the Waterfall model is not perfect. One of its main weaknesses, mentioned by \textcite{waterfall}, is its lack of flexibility in regards to change of requirements. As such, once the project leaves the requirements analysis or design phase, it may be difficult to make any changes to the project deliverable. Thus, this model is not suitable for projects where the requirements are not well understood or are likely to change. Finally, the deliverable is only available at the end of the project, so the end-users are unable to see the final product until the end of the project, nor can they provide any feedback during its development \parencite{waterfall}.

\subsubsection{Agile Model}

Another well-known SDLC model is the Agile model. Taking its roots from the Agile Manifesto, it describes a different way of developing software from the Waterfall model, with a focus on:

\begin{quote}
    \textit{Individuals and interactions over processes and tools, \\
    Working software over comprehensive documentation, \\
    Customer collaboration over contract negotiation, \\
    Responding to change over following a plan}
    \parencite{agile2}.
\end{quote}

The Agile model focuses on the ideas that requirements are not always well-known or cannot be predicted, accepting that change is inevitable and emphasis should be put on being able to accommodate any changes that may arise \parencite{agile}. Similarly, as the author mentions, the focus of this methodology is on continuous delivery of software and value to the customer. As such, it is integral for an Agile project to have a close customer involvement in the development process, to ensure that constant feedback is received.

Agile does come with its own drawbacks. One of the main issues with Agile is its lack of documentation and formal planning, especially in the early stages of the project \parencite{sdlc1}. Consequently, the Agile methodology may not be suitable for large scale projects, where extensive documentation and planning are required \parencite{agile, sdlc2}. Similarly, the Agile model may not be suitable for projects where the requirements are well understood, unlikely to change or where there may be strict regulations that guide how the project should be developed. Finally, \textcite{sdlc2} also mention that unfamiliarity with Agile frameworks could also be an impeding factor in the success of Agile projects, as the staff may not be familiar with Agile and require extensive training beforehand.

Agile has multiple frameworks that can be used to guide the development process, such as Scrum, Kanban, Lean, and Extreme Programming (XP).\ \textcite{scrumban} mention that Scrum is the most widely used Agile framework in software development. As such, the next sections will focus on Scrum and Kanban, due to their popularity and student's familiarity with these frameworks.

Scrum is an Agile framework, with its core idea being the division of the project into smaller, manageable parts called sprints. Each sprint usually lasts between 2-4 weeks and each sprint focuses on delivering value to the customer through working software features and close communication with client stakeholders \parencite{scrumban, agile}. Scrum employs a set of artifacts and ceremonies, that are used to guide the development process, such as the sprint and product backlog, daily scrums, backlog grooming/prioritization, and many more. Scrum also has a set of team roles, such as the Scrum Master, Product Owner, and the Development Team, that are responsible for the development process \parencite{scrumban}. 

On the other hand, Kanban is not as prescriptive as Scrum. Kanban focuses on visualizing the workflow of the project through a visual board with columns, cards and swimlanes. Kanban's main goal is to limit the work in progress through column WIP limits and a pull system to maximize the flow of work through the system \parencite{agile}. Kanban does not have specific roles or artifacts, but instead focuses on the continuous delivery of value to the customer through smaller batching and daily prioritizations \parencite{scrumban}.

Finally, there is also a possibility of combining these two frameworks into one, called Scrumban. Nowadays, the use of Scrum and Kanban together is becoming quite popular, with many teams employing both frameworks in their projects. As \textcite{scrumban} mention, it can be quite beneficial as it allows the team to `adopt the appropriate practices of both methods based on different situations to meet their needs'. The authors emphasize that the team members need to understand which elements of either framework bring value to the project and adapt them accordingly.

\subsection{A hybrid approach}

For many years, Waterfall (or the traditional approach) has been the most widely used model in software development projects, with Agile approaches gaining a lot of popularity in the recent years \parencite{hybrid1}. However, the authors note that a hybrid approach has also been emerging, being described as an approach that `combines methodologies and practices from more than one project management approach'. Results from surveys cited by articles show that the hybrid approach has been used by over 50\% of respondents \parencite{hybrid1,hybrid2}. The most common combinations that form this hybrid approach are `Scrum, Iterative Development, Kanban, Waterfall and DevOps', with the approach that combines Waterfall and Scrum being the most popular \parencite{hybrid2}.

An interesting finding is that even pure Agile approaches have been found to rarely exist, with hybrid Agile approaches being in reality most Agile implementations \parencite{hybrid1}. This may be due to multiple reasons, some of which may include regulations or safety standards in areas such as healthcare or defense systems documentation requirements or even time constraints. Thus, only the development part is usually done in an `Agile way' - with the rest of the project using the traditional approach as a `backbone' \parencite{hybrid2}.

So how would a hybrid approach work versus Waterfall or Agile? \textcite{hybrid2} explain that the hybrid approach uses Waterfall as its main methodology - still retaining the 6 general phases that were mentioned above. The authors note that the approach begins with the classic requirements analysis phase, where the general projects requirements are analysed on a high level, which can include system specifications, risks, resourcing and project scope/budget. This is followed by a design phase, where initial designs and diagrams are created and decisions regarding technology and tools are made. Next, the previously gathered requirements are broken down in smaller pieces (like User Stories or Epics) and transferred to Agile-specific artifacts such as the Product Backlog, that will be used in the next phase. Following this, the development phase starts, usually following the Scrum framework that was described above. Finally, the project ends with a testing phase, where system testing is done to ensure all components work well, followed by a operations or maintenance phase, where the software is deployed and maintenance support is offered.

\textcite{hybrid1} note that projects using either Agile, traditional or hybrid approach show similar levels of success in terms of budget, time and quality. However, the authors have found that agile and hybrid approaches perform much better on the customer satisfaction metric than the traditional counterpart.

\section{Requirements gathering}

As noted in the previous section, the requirements gathering phase is the first step in the software development process, whether it is done in a traditional, Waterfall, approach or in an Agile approach. As described by \textcite{reqanalysis2}, a requirement is a `necessary attribute in a system\ldots that identifies a capability, characteristic, or quality factor of a system in order for it to have value and utility to a user'. Multiple studies mention how proper requirement gathering and analysis play a pivotal role in the project quality and success, with a majority of project failures being attributed to poor requirements gathering \parencite{reqanalysis1, reqanalysis3, reqanalysis5}.

\subsection{Requirement types}

\textcite[4]{requirements} classifies requirements into 3 levels of abstraction: User requirements, System requirements and Design specifications. User requirements are the highest level of abstraction, are written in natural language and describe what services that system is expected to provide to the user. System requirements are more detailed, structured and precise, sometimes referred as functional specifications. Finally, design specifications are used by developers to implement the system, and is derived from analysis of system and design documentation. There 3 levels of abstraction are then later used during testing, each level corresponding to the respective testing level: User requirements are used in acceptance testing, System requirements are used in system and integration testing and Design specifications are used in unit testing \parencite[4]{requirements}.

The author also mentions that requirements can be classified into 2 categories: functional and non-functional requirements. Functional requirements describe the system's behavior, such as what the system should do and how it will react to different inputs, while non-functional requirements describe the system's quality attributes, such as performance, security, reliability, etc. \parencite[6]{requirements}.

When writing the requirements in a document, it is important to ensure that everything is written in a clear and concise manner to avoid any ambiguity. As such, \textcite[112]{requirements} comes with a some recommendations for writing requirements:
\begin{enumerate}
    \item Using a standard format for writing all requirements
    \item Using simple language in a consistent manner
    \item Avoiding the use of technical language unless necessary
    \item Avoiding vague or speculative terms such as `generally', `sometimes', instead using precise terms or even ranges/values
    \item Avoiding use of conjuctions such as `and', `or', `but' in a single requirement to not create multiple requirements in a single statement
\end{enumerate}

Additionally, the author points to \textcite{requirements2}, which provides a list of characteristics of individual requirements:
\begin{enumerate}
    \item Necessary
    \item Appropriate
    \item Unambiguous
    \item Complete
    \item Singular
    \item Feasible
    \item Verifiable
    \item Correct
    \item Conforming
\end{enumerate}

The same standard also provides some examples of requirements attributes within a requirement document, such as:
\begin{enumerate}
    \item Identification
    \item Owner
    \item Priority
    \item Risk
    \item Rationale
    \item Difficulty
    \item Type (functional/non-functional)
\end{enumerate}

\subsubsection{Requirements in Agile}

\textcite[191]{requirements} provides an explanation of requirements within Agile projects. The author mentions that in Agile projects, the most basic unit of requirements are usually written in the form of User Stories, which are short, simple descriptions of a feature desired by the customer. User Stories are written in a specific format, such as `As a [user], I want to [action] so that [benefit]'. A list of other User Story components is given by the author:
\begin{enumerate}
    \item Title
    \item Acceptance test/criteria - a list of conditions that must be met for the story to be considered complete
    \item Priority
    \item Story points - estimated time to implement the user story
    \item Description
\end{enumerate}

User stories are part of the Product and Sprint backlog - the former one containing the list of requirements for the whole project and the latter containing the list of requirements for the current sprint/iteration.

\subsection{Stakeholders}

\textcite[34]{requirements} explains that stakeholders represent the `set of individuals who have some interest (a stake) in the success (or failure) of the system in question'. The author continues that there may be many types of stakeholders and stresses the importance of accurately and completely identifying all possible stakeholders for a system. Identification of all possible stakeholders needs to be done in the early stages of the project, as leaving out key stakeholder could lead to missing out on important requirements or constraints later on the project. 

After identifying the stakeholders, it is important to do a stakeholder analysis by understanding the stakeholders' interests, needs, expectations, and influence on the project and then mapping them on a stakeholder matrix. One such matrix is the Influence/Interest grid, which classifies stakeholders based on their power and interest in the project \parencite{stakeholders}. The matrix divides stakeholders into 4 categories:
\begin{enumerate}
    \item Low influence, low interest - try to increase interest
    \item Low influence, high interest - keep informed 
    \item High influence, low interest - engage and consult on interest area
    \item High influence, high interest - key players, involve in decision making and engage regularly
\end{enumerate}

\subsection{Requirement gathering techniques}

There are multiple requirement gathering techniques, the most popular ones being interviews, collaborative meetings, prototyping, modeling, brainstorming, storyboards, document analysis and ethnography (observing users interacting with an existing system) \parencite{reqanalysis1,reqanalysis2, reqanalysis3, reqanalysis4}. One of the studies interviewed  several individuals with multiple years of experience in the field of requirement gathering and analysis. As a result, the authors found that the most used requirement gathering techniques were collaborative meetings, interviews, ethnography and modeling \parencite{reqanalysis1}. Another study by \textcite{reqanalysis6} proposes a framework for improved requirement gathering in Scrum with a real-life case study of an IT project in Norway. The authors introduce the framework as being a series of 3 sections: pre-elicitation phase, where a high-level overview and breakdown of the requirements is done during an interview with the stakeholders, a mid-elicitation phase, where the a deep dive into the requirements is done through the usage of mind maps and a post-elicitation phase, where the output of the previous phase is used to feed into a Scrum Product Backlog and later a Sprint Backlog.

\subsection{Interview technique considerations}

Multiple research papers point to interviews being recognised as the most commonly used technique for requirement gathering \parencite{interviews5,interviews1,interviews2}. Interviews can be divided into 3 different types: structured, semi-structured and unstructured, with the first type being more effective at gathering information from stakeholders versus the other 2 types \parencite{interviews5,interviews6}. 

Two articles by \textcite{interviews4, interviews3} suggest a list of recommended practices for conducting interviews, such as:
\begin{enumerate}
    \item Encouraging deep thinking through situational thinking or providing rationales.
    \item Avoiding ambiguity by asking clarifying questions.
    \item Being flexible by probing into relevant topics that have arisen during the discussion and not being rigidly attached to the interview script.
    \item Verifying that the conclusion/summary aligns with the customer's vision.
    \item Using projective techniques, such as analogies, scenarios, stories, and role-playing.
    \item Having the stakeholder teach the analyst about a specific topic or a complex concept.
    \item Stating the goals of the interview at the beginning and offering stakeholders time at the end to add any missing information.
\end{enumerate}

On the other hand, two studies have been found that provide some insights into the potential mistakes that student analysts may do during requirement gathering sessions. One such study done by \textcite{interviews1} mentions the following mistakes:
\begin{enumerate}
    \item Wrong opening - need to understand the context of the problem first, so it is important to understand the system as-is and how it would change with the new system before talking about the system itself.
    \item Not leveraging ambiguity - ambiguity can reveal gaps in the knowledge between the analyst and the customer and be used to elicit important system-related knowledge.
    \item Implicit goals - it is important to either explicitly ask/suggest clear goals or at least ask for more clarification.
    \item Implicit stakeholders - not taking into account 3rd party stakeholders.
    \item Non-functional requirements not considered
    \item Interviews sounding like interrogations - to combat this, the authors recommend using techniques such as imagining, scenarios and teaching to let the customer explain their vision.
    \item Problems in phrasing questions - some questions can be direct, so they need some background information to be understood.
    \item Wrong closing - the authors stress the importance of a interview summary at the end of the session, to receive feedback from the customer if necessary.
\end{enumerate}

A similar study by \textcite{interviews2} suggests the following mistakes that can be made during interviews:

\begin{enumerate}
    \item Question formulation - asking vague, technical, irrelevant or long questions.
    \item Question omission - not asking about stakeholders or existing business processes or not doing follow-up questions.
    \item Order of interview - incorrect opening (no introductions, no description of the current situation) or ending (no summary)
    \item Communication skills - too much technical jargon, not listening to the customer, interview sounding too strict or passiveness of the analyst.
    \item Customer interaction - not building rapport with the customer
    \item Planning - lack of planning in terms of sequence of questions to ask
\end{enumerate}

\section{System design}

\section{Tech stack}

\subsection{Database}

A database is a collection of structured data that is stored electronically on a computer and that is controlled by a database management system (DBMS), which also allowes end-users to access the database records \parencite{databases2}. There are several types of databases, such as: relational (SQL), NoSQL databases, graph databases, object-oriented databases and many more. Due to the prototype nature of the project, it is not expected that the data used in the system will be complex, so the next subsections will focus on the two most common types of databases - relational and NoSQL databases.

\subsubsection{Relational databases}

Relational databases are collections of data where the data is stored in rows and tables, linked through keys that allow different types of relationships: one-to-one, one-to-many and many-to-many \parencite{databases}. SQL (Structured Query Language) is the programming language used to query relational databases. \textcite{databases} mention the advantages of using relational databases is in their ability to handle structured data in well-organized manner by using schemas and tables, making it easy to query, even for complex queries. Additionally, the authors argue that by following the ACID (Atomicity, Consistency, Isolation, Durability) properties, relational databases ensure that the data within is consistent and reliable. Finally, relational databases are widely used and have a large community of users, which makes it easier to find support and resources. Example of relational databases include MySQL, PostgreSQL, Oracle, and Microsoft SQL Server.

\subsubsection{NoSQL databases}

NoSQL databases, on the other hand, are databases that allow developers to work with unstructured data (such as documents, images, etc) without relying on rigid schemas, tables or relationships between data \parencite{databases}. As described by the authors, NoSQL databases generally fall into four different structures: key-value stores, document stores, column-family stores, and graph databases. Similarly to relational databases, NoSQL databases follow their own set of properties, such as CAP (Consistency, Availability, Partition Tolerance) theorem, which states that a distributed system can only guarantee two of the three properties at the same time. While NoSQL databases are not as widely used as relational databases, they are gaining popularity due to their ability to handle large amounts of data and their flexibility in handling unstructured data. Examples of NoSQL databases include MongoDB, Cassandra, Couchbase, and Redis.

\subsection{Backend}

\subsection{Frontend}

\section{Machine Learning models}

\section{Gap Analysis}

\subsection{athenahealth}

https://www.athenahealth.com/solutions/electronic-health-records
https://www.selecthub.com/medical-software/ehr/ehr-examples/

Positive things:

\begin{enumerate}
    \item Patient portal to manage appointments
    \item Mobile applications
    \item Usage of coding systems like ICD-10 and CPT
    \item Clean UI
    \item Easy to view patient history
    \item Easy to add vitals
    \item Easy to create patient report through clicking of boxes with  pre-defined text
    \item A lot of reporting/chart features
    \item Auto population of info from scanned documents
    \item Billing management
\end{enumerate}

\subsection{drchrono}

https://www.drchrono.com/

Positive things:

\begin{enumerate}
    \item Virtual visits through telemedicine
    \item Clean UI
    \item Billing management
    \item Mobile app
    \item Online scheduling tools
    \item Easy to add vitals - default and custom view
    \item Lab integration
    \item Custom templates and forms (drag and drop elements) - filter by speciality or keywords
    \item Speech to text 
    \item Library of forms, easy to create charts
    \item Easy to add text in fields by selecting existing options
    \item medical codes 
\end{enumerate}

\subsection{AdvancedMD}

https://www.advancedmd.com/

Positive things:

\begin{enumerate}
    \item 
\end{enumerate}

\subsection{Netsmart}

https://www.ntst.com/

Positive things:

\begin{enumerate}
    \item 
\end{enumerate}


EHR system features:

1. Customization and flexibility
2. Use of a patient portal and automated patient communication features - access to records, appointment management, medication requests, virtual comms
3. System integration (billing, test labs, etc)
4. Business Intelligence (resource management, scheduling, etc)
5. Analytics
6. Telehealth
7. Access to patient history
8. Processing claims
9. Digital vital charts
10. Voice recognition and other AI features
11. Generating reports, notes, etc
12. Prescriptions
13. Mobile design
14. Security and privacy