\chapter{Literature Review}
%in case I want to refer to this chapter, I can use \ref{chap:lit_review}
\label{chap:lit_review}

This chapter will provide a review of the existing literature, which will be used guide the student in their planning and development efforts of the project.

\noindent As such, it will be covering the following areas:
\begin{itemize}
    \item Software development methodologies
    \item Requirement gathering
    \item System design
    \item Tech stack
    \item Machine Learning models
    \item Gap Analysis
\end{itemize}


\section{Software development methodologies}

\subsection{Software Development Life Cycle}

The Software Development Life Cycle (SDLC) is a process used to guide the development of software applications or systems \parencite{sdlc1}. The SDLC consists of multiple phases, each with its own set of activities and deliverables. \textcite{sdlc2} outline the phases of the SDLC as following:
\begin{enumerate}
    \item Requirement gathering and analysis phase - This phase involves gathering and analyzing the requirements of the software to be developed. These requirements are gathered from the project stakeholders and saved in a specific document. Based on the requirements gathered, a development plan is created and a feasibility study is conducted.
    \item Design phase - This phase involves representing the previously gathered requirements in a project design written in a more technical manner, that will later guide the developers to create and implement the software. 
    \item Implementation phase - This phase involves the actual development of the software. Additionally, some smaller unit tests may occur during this phase as parts of the software are developed.
    \item Testing phase - This phase focuses on testing the software to ensure that it meets the requirements and is free of bugs. This phase may involve multiple types of testing, such as unit testing, integration testing,  and system testing. \textcite{testing} describes the different types of tests as following:
    \begin{itemize}
    \item Unit testing - This type of test is done on the lowest level of the software, testing individual units or components of the software.
    \item Integration testing - This type of test is performed on two or more units combined together, usually focusing on the interfaces between these components.
    \item System testing - This type of test focuses on the `end-to-end quality of the entire system', testing it as a whole based on the system requirement specification.
    \end{itemize}
    \item Maintenance phase - This phase involves the deployment and maintenance of the software. Additionally, this phase may include user acceptance testing, where the software is handed over to the end-users to ensure that it meets their needs \parencite{testing}. 
\end{enumerate}


\subsection{SDLC Models}

The literature describes several SDLC models that have been used in the development of software applications. \textcite{sdlc1, sdlc2} outline the most common SDLC models:
\begin{itemize}
    \item Waterfall Model
    \item V Model
    \item Spiral Model
    \item Iterative Model
    \item Agile model
\end{itemize}

Due to the nature of the project being different to traditional software development projects, and the student's familiarity with only Waterfall and Agile models, the next sections will only focus on these two models.

\subsubsection{Waterfall Model}

The Waterfall Model is probably the most well-known SDLC model. Waterfall is a linear model, where the development process is divided into distinct, sequential phases that follow the SDLC. As such, each phase must be completed before the next phase can begin.

The Waterfall Model's strengths lie in its simplicty of use, ease of understanding and providing a structured approach to a project \parencite{waterfall}. An additional stregth of the Waterfall model that the authors note is its extensive documentation and planning, which is done in the early stages of a project, but also maintened throughout the project's lifecycle. These two factors also help minimize the overhead that comes with planning and management of a project, which in the case of Waterfall is done in the early stages of the project.

However, the Waterfall model is not perfect. One of its main weaknesses, mentioned by \textcite{waterfall}, is its lack of flexibility in regards to change of requirements. As such, once the project leaves the requirements analysis or design phase, it may be difficult to make any changes to the project deliverable. Thus, this model is not suitable for projects where the requirements are not well understood or are likely to change. Finally, the deliverable is only available at the end of the project, so the end-users are unable to see the final product until the end of the project, nor can they provide any feedback during its development \parencite{waterfall}.

\subsubsection{Agile Model}

Another well-known SDLC model is the Agile model. Taking its roots from the Agile Manifesto, it describes a different way of developing software from the Waterfall model, with a focus on:

\begin{quote}
    \textit{Individuals and interactions over processes and tools, \\
    Working software over comprehensive documentation, \\
    Customer collaboration over contract negotiation, \\
    Responding to change over following a plan}
    \parencite{agile2}.
\end{quote}

The Agile model focuses on the ideas that requirements are not always well-known or cannot be predicted, accepting that change is inevitable and emphasis should be put on being able to accommodate any changes that may arise \parencite{agile}. Similarly, as the author mentions, the focus of this methodology is on continuous delivery of software and value to the customer. As such, it is integral for an Agile project to have a close customer involvement in the development process, to ensure that constant feedback is received.

Agile does come with its own drawbacks. One of the main issues with Agile is its lack of documentation and formal planning, especially in the early stages of the project \parencite{sdlc1}. Consequently, the Agile methodology may not be suitable for large scale projects, where extensive documentation and planning are required \parencite{agile, sdlc2}. Similarly, the Agile model may not be suitable for projects where the requirements are well understood, unlikely to change or where there may be strict regulations that guide how the project should be developed. Finally, \textcite{sdlc2} also mention that unfamiliarity with Agile frameworks could also be an impeding factor in the success of Agile projects, as the staff may not be familiar with Agile and require extensive training beforehand.

Agile has multiple frameworks that can be used to guide the development process, such as Scrum, Kanban, Lean, and Extreme Programming (XP).\ \textcite{scrumban} mention that Scrum is the most widely used Agile framework in software development. As such, the next sections will focus on Scrum and Kanban, due to their popularity and student's familiarity with these frameworks.

Scrum is an Agile framework, with its core idea being the division of the project into smaller, manageable parts called sprints. Each sprint usually lasts between 2-4 weeks and each sprint focuses on delivering value to the customer through working software features and close communication with client stakeholders \parencite{scrumban, agile}. Scrum employs a set of artifacts and ceremonies, that are used to guide the development process, such as the sprint and product backlog, daily scrums, backlog grooming/prioritization, and many more. Scrum also has a set of team roles, such as the Scrum Master, Product Owner, and the Development Team, that are responsible for the development process \parencite{scrumban}. 

On the other hand, Kanban is not as prescriptive as Scrum. Kanban focuses on visualizing the workflow of the project through a visual board with columns, cards and swimlanes. Kanban's main goal is to limit the work in progress through column WIP limits and a pull system to maximize the flow of work through the system \parencite{agile}. Kanban does not have specific roles or artifacts, but instead focuses on the continuous delivery of value to the customer through smaller batching and daily prioritizations \parencite{scrumban}.

Finally, there is also a possibility of combining these two frameworks into one, called Scrumban. Nowadays, the use of Scrum and Kanban together is becoming quite popular, with many teams employing both frameworks in their projects. As \textcite{scrumban} mention, it can be quite beneficial as it allows the team to `adopt the appropriate practices of both methods based on different situations to meet their needs'. The authors emphasize that the team members need to understand which elements of either framework bring value to the project and adapt them accordingly.

\subsection{A hybrid approach}

For many years, Waterfall (or the traditional approach) has been the most widely used model in software development projects, with Agile approaches gaining a lot of popularity in the recent years \parencite{hybrid1}. However, the authors note that a hybrid approach has also been emerging, being described as an approach that `combines methodologies and practices from more than one project management approach'. Results from surveys cited by articles show that the hybrid approach has been used by over 50\% of respondents \parencite{hybrid1,hybrid2}. The most common combinations that form this hybrid approach are `Scrum, Iterative Development, Kanban, Waterfall and DevOps', with the approach that combines Waterfall and Scrum being the most popular \parencite{hybrid2}.

An interesting finding is that even pure Agile approaches have been found to rarely exist, with hybrid Agile approaches being in reality most Agile implementations \parencite{hybrid1}. This may be due to multiple reasons, some of which may include regulations or safety standards in areas such as healthcare or defense systems documentation requirements or even time constraints. Thus, only the development part is usually done in an `Agile way' - with the rest of the project using the traditional approach as a `backbone' \parencite{hybrid2}.

So how would a hybrid approach work versus Waterfall or Agile? \textcite{hybrid2} explain that the hybrid approach uses Waterfall as its main methodology - still retaining the 6 general phases that were mentioned above. The authors note that the approach begins with the classic requirements analysis phase, where the general projects requirements are analysed on a high level, which can include system specifications, risks, resourcing and project scope/budget. This is followed by a design phase, where initial designs and diagrams are created and decisions regarding technology and tools are made. Next, the previously gathered requirements are broken down in smaller pieces (like User Stories or Epics) and transferred to Agile-specific artifacts such as the Product Backlog, that will be used in the next phase. Following this, the development phase starts, usually following the Scrum framework that was described above. Finally, the project ends with a testing phase, where system testing is done to ensure all components work well, followed by a operations or maintenance phase, where the software is deployed and maintenance support is offered.

\textcite{hybrid1} note that projects using either Agile, traditional or hybrid approach show similar levels of success in terms of budget, time and quality. However, the authors have found that agile and hybrid approaches perform much better on the customer satisfaction metric than the traditional counterpart.

\subsection{Conclusion}

Based on the research above, the student has decided that he will be using a hybrid approach, with Waterfall as the main methodology for planning managing the project. The development part of the project will be done using ScrumBan, so that the student will be able to utilise elements from both frameworks. There are several reasons for this choice:

\begin{enumerate}
    \item The nature of the project - the student is working on a project that has a limited timeframe (about 6-7 months) and is of a smaller scale. 
    \item Documentation requirements - the student is required to document the progress during the project in this report, including the requirements gathered, design considerations and implementation decisions and outcomes. 
    \item Regulatory requirements - the student is required to adhere to the regulations and standards of the healthcare industry, which may require extensive documentation and planning.
    \item Customer involvement - the student will be working closely with the project stakeholder, who will be providing feedback and guidance throughout the project.
    \item Familiarity with both Agile and Waterfall - the student has experience with both Agile (specifically Scrum and Kanban) and Waterfall methodologies, and has worked on projects that have used both approaches.
\end{enumerate}

The student will use Jira Software as their project management tool, which is one of the most popular project management tool for software development projects that supports working with Agile frameworks such as Scrum and Kanban \parencite{atlassian}.

\section{Requirements gathering}

As noted in the previous section, the requirements gathering phase is the first step in the software development process, whether it is done in a traditional, Waterfall, approach or in an Agile approach. As described by \textcite{reqanalysis2}, a requirement is a `necessary attribute in a system\ldots that identifies a capability, characteristic, or quality factor of a system in order for it to have value and utility to a user'. Multiple studies mention how proper requirement gathering and analysis play a pivotal role in the project quality and success, with a majority of project failures being attributed to poor requirements gathering \parencite{reqanalysis1, reqanalysis3, reqanalysis5}.

\textcite{reqanalysis2} explains that requirements should be `necessary, verifiable, attainable, unambiguous, complete, consistent, traceable, concise, implementation-free and have a unique identifier'. The author mentions that the requirement should focus on the `what' and not the `how', as the `how' is usually left to the developers to decide. Additionally, the author recommends focusing on the rationale behind the requirement, as it can help in understanding the requirement better and reduce the overall number of requirements. Finally, the author recommends beginning the process with an understanding the business requirements, which will help in creating the vision and scope that explains the background of the project and describes the system that needs to be developed.

INSERT INFO ABOUT REQUIREMENT ATTRIBUTES/TYPES HERE + AGILE USER STORIES

There are multiple requirement gathering techniques, the most popular ones being interviews, collaborative meetings, prototyping, modeling, brainstorming, storyboards, document analysis and ethnography (observing users interacting with an existing system) \parencite{reqanalysis1,reqanalysis2, reqanalysis3, reqanalysis4}. One of the studies interviewed  several individuals with multiple years of experience in the field of requirement gathering and analysis. As a result, the authors found that the most used requirement gathering techniques were collaborative meetings, interviews, ethnography and modeling \parencite{reqanalysis1}. Another study by \textcite{reqanalysis6} proposes a framework for improved requirement gathering in Scrum with a real-life case study of an IT project in Norway. The authors introduce the framework as being a series of 3 sections: pre-elicitation phase, where a high-level overview and breakdown of the requirements is done during an interview with the stakeholders, a mid-elicitation phase, where the a deep dive into the requirements is done through the usage of mind maps and a post-elicitation phase, where the output of the previous phase is used to feed into a Scrum Product Backlog and later a Sprint Backlog.

\subsection{Interview technique considerations}



\section{System design}

\section{Tech stack}

\subsection{Database}

A database is a collection of structured data that is stored electronically on a computer and that is controlled by a database management system (DBMS), which also allowes end-users to access the database records \parencite{databases2}. There are several types of databases, such as: relational (SQL), NoSQL databases, graph databases, object-oriented databases and many more. Due to the prototype nature of the project, it is not expected that the data used in the system will be complex, so the next subsections will focus on the two most common types of databases - relational and NoSQL databases.

\subsubsection{Relational databases}

Relational databases are collections of data where the data is stored in rows and tables, linked through keys that allow different types of relationships: one-to-one, one-to-many and many-to-many \parencite{databases}. SQL (Structured Query Language) is the programming language used to query relational databases. \textcite{databases} mention the advantages of using relational databases is in their ability to handle structured data in well-organized manner by using schemas and tables, making it easy to query, even for complex queries. Additionally, the authors argue that by following the ACID (Atomicity, Consistency, Isolation, Durability) properties, relational databases ensure that the data within is consistent and reliable. Finally, relational databases are widely used and have a large community of users, which makes it easier to find support and resources. Example of relational databases include MySQL, PostgreSQL, Oracle, and Microsoft SQL Server.

\subsubsection{NoSQL databases}

NoSQL databases, on the other hand, are databases that allow developers to work with unstructured data (such as documents, images, etc) without relying on rigid schemas, tables or relationships between data \parencite{databases}. As described by the authors, NoSQL databases generally fall into four different structures: key-value stores, document stores, column-family stores, and graph databases. Similarly to relational databases, NoSQL databases follow their own set of properties, such as CAP (Consistency, Availability, Partition Tolerance) theorem, which states that a distributed system can only guarantee two of the three properties at the same time. While NoSQL databases are not as widely used as relational databases, they are gaining popularity due to their ability to handle large amounts of data and their flexibility in handling unstructured data. Examples of NoSQL databases include MongoDB, Cassandra, Couchbase, and Redis.

\subsection{Backend}

\subsection{Frontend}

\section{Machine Learning models}

\section{Gap Analysis}